<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Izskrien Latviju! - Optimized</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body, html { height: 100%; margin: 0; padding: 0; font-family: 'Montserrat', sans-serif; }
        #map { width: 100%; height: 90vh; }
        #header { 
            position: fixed; 
            top: 10px; 
            left: 50%; 
            transform: translateX(-50%); 
            display: flex; 
            align-items: center; 
            z-index: 1001;
            background: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #search-bar { padding: 8px; font-size: 16px; border-radius: 4px; width: 200px; margin-right: 10px; border: 1px solid #ddd; }
        #search-btn, #create-btn { 
            font-size: 16px; 
            padding: 8px 12px; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
            color: white;
            margin: 0 5px;
        }
        #search-btn { background-color: #333; }
        #create-btn { background-color: #4CAF50; }
        #loading { 
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1002;
        }
    </style>
</head>
<body>
    <div id="header">
        <input id="search-bar" type="text" placeholder="Ievadiet pilsētu...">
        <button id="search-btn">Meklēt</button>
        <button id="create-btn">Aiziet!</button>
    </div>
    <div id="loading">Aprēķina maršrutu...</div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

    <script>
// KD-Tree Implementation
class KDTree {
    constructor(points, depth = 0, axis = 0) {
        if (points.length === 0) {
            this.root = null;
            return;
        }

        const k = 2; // 2D points (lat, lng)
        axis = axis % k;

        // Sort points based on current axis
        points.sort((a, b) => a[axis] - b[axis]);

        const medianIdx = Math.floor(points.length / 2);
        this.root = {
            point: points[medianIdx],
            left: new KDTree(points.slice(0, medianIdx), depth + 1, axis + 1),
            right: new KDTree(points.slice(medianIdx + 1), depth + 1, axis + 1),
            axis: axis
        };
    }

    findNearest(target, maxPoints = 1) {
        if (!this.root) return [];
        
        const nearestPoints = [];
        this._findNearest(this.root, target, nearestPoints, maxPoints);
        
        return nearestPoints
            .sort((a, b) => a.distance - b.distance)
            .slice(0, maxPoints)
            .map(item => item.point);
    }

    _findNearest(node, target, nearestPoints, maxPoints) {
        if (!node) return;

        const distance = this._distance(target, node.point);
        nearestPoints.push({ point: node.point, distance });

        const axis = node.axis;
        const value = target[axis];
        const nodeValue = node.point[axis];

        // Recursively search the closer side
        const nextNode = value < nodeValue ? node.left : node.right;
        const otherNode = value < nodeValue ? node.right : node.left;

        this._findNearest(nextNode, target, nearestPoints, maxPoints);

        // Check if we need to search the other side
        if (Math.abs(nodeValue - value) < Math.max(...nearestPoints.map(p => p.distance)) || 
            nearestPoints.length < maxPoints) {
            this._findNearest(otherNode, target, nearestPoints, maxPoints);
        }
    }

    _distance(p1, p2) {
        return Math.sqrt(
            Math.pow(p1[0] - p2[0], 2) + 
            Math.pow(p1[1] - p2[1], 2)
        );
    }
}

// Main Application
let map, drawnItems, selectedArea, kdtree, latviaBorder;
const worker = new Worker('pathWorker.js');

async function initializeMap() {
    map = L.map('map').setView([56.8796, 24.6032], 7);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 17,
        minZoom: 5
    }).addTo(map);

    drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    const drawControl = new L.Control.Draw({
        draw: {
            polygon: false,
            rectangle: true,
            circle: false,
            marker: false,
            polyline: false
        },
        edit: {
            featureGroup: drawnItems,
            remove: true
        }
    });
    map.addControl(drawControl);

    try {
        const response = await fetch('latvia.json');
        if (!response.ok) throw new Error("Failed to load latvia.json");
        latviaBorder = await response.json();
        kdtree = new KDTree(latviaBorder);
    } catch (error) {
        console.error("Error loading border data:", error);
        alert("Failed to load Latvia border data");
        return;
    }

    map.on(L.Draw.Event.CREATED, function(event) {
        drawnItems.clearLayers();
        drawnItems.addLayer(event.layer);
        selectedArea = event.layer.getBounds();
    });

    document.getElementById('search-btn').addEventListener('click', searchPlace);
    document.getElementById('create-btn').addEventListener('click', calculateOptimalRoute);
    document.getElementById('search-bar').addEventListener('keypress', e => {
        if (e.key === 'Enter') searchPlace();
    });

    worker.onmessage = function(e) {
        const path = e.data;
        if (path) {
            L.polyline(path, { 
                color: 'blue', 
                weight: 3 
            }).addTo(map);
        }
        document.getElementById('loading').style.display = 'none';
    };
}

async function searchPlace() {
    const query = document.getElementById('search-bar').value;
    if (!query) return;

    try {
        const response = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&q=${query}`
        );
        const data = await response.json();
        
        if (data && data[0]) {
            const lat = parseFloat(data[0].lat);
            const lon = parseFloat(data[0].lon);
            map.flyTo([lat, lon], 13);
        } else {
            alert('Location not found');
        }
    } catch (error) {
        console.error('Error searching location:', error);
        alert('Error searching location');
    }
}

async function calculateOptimalRoute() {
    if (!selectedArea || !kdtree) {
        alert("Please select an area and ensure border data is loaded.");
        return;
    }

    document.getElementById('loading').style.display = 'block';

    const { _southWest: sw, _northEast: ne } = selectedArea;
    const query = `[out:json];way["highway"](${sw.lat},${sw.lng},${ne.lat},${ne.lng});out geom;`;

    try {
        const response = await fetch(
            `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`
        );
        if (!response.ok) throw new Error("Failed to fetch road data");

        const data = await response.json();
        const roadNetwork = processRoadNetwork(data.elements);
        
        // Find border points within selected area
        const borderPoints = latviaBorder.filter(point => 
            point[0] >= sw.lat && point[0] <= ne.lat &&
            point[1] >= sw.lng && point[1] <= ne.lng
        );

        // Use KD-tree to find nearest road points
        const roadPoints = borderPoints.map(point => 
            kdtree.findNearest(point)[0]
        );

        // Start worker calculation
        worker.postMessage({
            roadNetwork,
            points: roadPoints
        });

    } catch (error) {
        console.error("Error calculating route:", error);
        alert("Error calculating route");
        document.getElementById('loading').style.display = 'none';
    }
}

function processRoadNetwork(elements) {
    const network = {};
    elements.forEach(road => {
        if (road.type === "way" && road.geometry) {
            road.geometry.forEach((node, i) => {
                if (i < road.geometry.length - 1) {
                    const current = [node.lat, node.lon];
                    const next = [road.geometry[i + 1].lat, road.geometry[i + 1].lon];
                    
                    const currentKey = `${current[0]},${current[1]}`;
                    const nextKey = `${next[0]},${next[1]}`;
                    
                    if (!network[currentKey]) network[currentKey] = [];
                    if (!network[nextKey]) network[nextKey] = [];
                    
                    network[currentKey].push(next);
                    network[nextKey].push(current);
                }
            });
        }
    });
    return network;
}

initializeMap();
    </script>
</body>
</html>